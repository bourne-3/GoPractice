### Array
- 初始化值之后，获得对应元素类型的零值，而不是null
- 长度推导：连数组的长度都不想指定，不过没有关系，使用...代替就好了，Go会自动推导出数组的长度。
- 指定初始化 例如 {n:12}
- 指针数组。要给下标为th的位置赋值，需要先分配内存
- 函数间传递数组：
  - 如果变量是个数组，那么就会整个复制，并传递给函数。如果数组非常大，比如长度100多万，那么这对内存是一个很大的开销。
  - 传递指针只是传递指针该引用的指针副本，仍然是可以修改原数组的值

### Slice
- 切片对象非常小，是因为它是只有3个字段的数据结构：一个是指向底层数组的指针，一个是切片的长度，一个是切片的容量。
- 容量必须>=长度。需要切片扩充后才可以访问(cap - len)的值。
- 字面量创建数组和切片的不同：有无声明一个值在[]中
- nil切片和空切片
  - 它们的长度和容量都是0，但是它们指向底层数组的指针不一样，nil切片意味着指向底层数组的指针为nil，而空切片对应的指针是个地址。
- 共用底层数组：新的切片和原切片共用的是一个底层数组，所以当修改的时候，底层数组的值就会被改变
- len和cap的计算公式：
  - 对于底层数组容量是k的切片slice[i:j]来说
    - 长度：j - i
    - 容量：k - i
  - 实际中使用len和cap的api调用即可
- 创建新切片的时候，最好要让新切片的长度和容量一样，这样我们在追加操作的时候就会生成新的底层数组，和原有数组分离，就不会因为共用底层数组而引起奇怪问题,因为共用数组的时候修改内容，会影响多个切片。
- 函数中传递切片
  - 切片是3个字段（指向底层数组的指针）构成的结构类型。在传递复制切片的时候，其底层数组不会被复制，也不会受影响，复制只是复制的切片本身，不涉及底层数组。

### Map
- namesMap := make()的方法创建，然后再赋值
- 也可以使用 var 的方式创建一个nil的map
- 同时也可以使用字面的方式

### Type
- 基本类型
  - 本质上是原始类型，也就是不可改变的，所以对他们进行操作，一般都会返回一个新创建的值，所以把这些值传递给函数时，其实传递的是一个值的副本。
- 引用类型
  - 切片、map、接口、函数类型以及chan
  - （重要）引用类型之所以可以引用，是因为我们创建引用类型的变量，其实是一个标头值，标头值里包含一个指针，指向底层的数据结构，当我们在函数中传递引用类型时，其实传递的是这个标头值的副本，它所指向的底层结构并没有被复制传递，这也是引用类型传递高效的原因。
    - 标头值
  - 本质上，我们可以理解函数的传递都是值传递，只不过引用类型传递的是一个指向底层数据的指针，所以我们在操作的时候，可以修改共享的底层数据的值，进而影响到所有引用到这个共享底层数据的变量。

### Method and Function
- 在Go语言中，函数和方法不太一样，有明确的概念区分。
  - 方法有receiver，函数没有
- 对于接收者需要注意：是值接收者还是指针接收者
  - 如果是值接收者，在方法中修改是不会改动原有值
  - 如果是指针接收者，就会改变原来的值
  - 两者在调用方法会出现一个自动转型的情况
    - （重要）Go的编译器自动会帮我们取指针（以及解引用），以满足接收者的要求。
    - Go语言编译器会帮我们进行自动转义的

### Interface
- 抽象就是接口的优势，它不用和具体的实现细节绑定在一起，我们只需定义接口，告诉编码人员它可以做什么，这样我们可以把具体实现分开
- 赋值操作执行后，如果我们对接口方法执行调用，其实是调用存储的用户定义类型的对应方法，这里我们可以把用户定义的类型称之为实体类型
  - 接口其实是一个引用类型
- 使用值还是指针receiver？
  - 实体类型以值接收者实现接口的时候，不管是实体类型的值，还是实体类型值的指针，都实现了该接口。
    - &d和d都可以传递给接口
  - 实体类型以指针接收者实现接口的时候，只有指向这个类型的指针才被认为实现了该接口
    - 也就是使用 &d

### EmbedType
- 把已有的类型声明在新的类型里的一种方式，这种功能对代码复用非常重要。
  - 在Go语言中，没有继承的概念，Go提倡的代码复用的方式是组合
- 如果内部类型实现了某个接口，那么外部类型也被认为实现了这个接口。我们稍微改造下例子看下

### Visible
- 如果一个类型的名字是以大写开头，那么其他包就可以访问；如果以小写开头，其他包就不能访问

### Goroutine
- go语言中并发指的是让某个函数独立于其他函数运行的能力，一个goroutine就是一个独立的工作单元
  - Go的runtime（运行时）会在逻辑处理器上调度这些goroutine来运行，一个逻辑处理器绑定一个操作系统线程，所以说goroutine不是线程，它是一个协程
- 通道：目的 在多个goroutine发送和接受共享的数据，达到数据同步的目的。
  - 无缓冲通道
    - 无缓冲的通道指的是通道的大小为0，也就是说，这种类型的通道在接收前没有能力保存任何值，它要求发送goroutine和接收goroutine同时准备好，才可以完成发送和接收操作。
    - 如果没有同时准备好的话，先执行的操作就会阻塞等待，直到另一个相对应的操作准备好为止。
  - 缓冲通道  （其实是一个队列）
    - 当队列满的时候，发送操作会阻塞；当队列空的时候，接受操作会阻塞。有缓冲的通道，不要求发送和接收操作时同步的，相反可以解耦发送和接收操作。
      - 注意不需要同步阻塞
  - 单向通道
    - var send chan<- int //只能发送
    - var receive <-chan int //只能接收