### Array
- 初始化值之后，获得对应元素类型的零值，而不是null
- 长度推倒：连数组的长度都不想指定，不过没有关系，使用...代替就好了，Go会自动推导出数组的长度。
- 指定初始化
- 指针数组。要给下标为th的位置赋值，需要先分配内存
- 函数间传递数组：
  - 如果变量是个数组，那么就会整个复制，并传递给函数。如果数组非常大，比如长度100多万，那么这对内存是一个很大的开销。
  - 传递指针只是传递指针该引用的指针副本，仍然是可以修改原数组的值

### Slice
- 切片对象非常小，是因为它是只有3个字段的数据结构：一个是指向底层数组的指针，一个是切片的长度，一个是切片的容量。
- 容量必须>=长度。需要切片扩充后才可以访问(cap - len)的值。
- 字面量创建数组和切片的不同：有无声明一个值在[]中
- nil切片和空切片
  - 它们的长度和容量都是0，但是它们指向底层数组的指针不一样，nil切片意味着指向底层数组的指针为nil，而空切片对应的指针是个地址。
- 共用底层数组：新的切片和原切片共用的是一个底层数组，所以当修改的时候，底层数组的值就会被改变
- len和cap的计算公式：
  - 对于底层数组容量是k的切片slice[i:j]来说
    - 长度：j - i
    - 容量：k - i
  - 实际中使用len和cap的api调用即可
- 创建新切片的时候，最好要让新切片的长度和容量一样，这样我们在追加操作的时候就会生成新的底层数组，和原有数组分离，就不会因为共用底层数组而引起奇怪问题,因为共用数组的时候修改内容，会影响多个切片。
- 函数中传递切片
  - 切片是3个字段（指向底层数组的指针）构成的结构类型。在传递复制切片的时候，其底层数组不会被复制，也不会受影响，复制只是复制的切片本身，不涉及底层数组。
